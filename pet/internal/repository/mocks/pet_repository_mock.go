// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/escoutdoor/kotopes/pet/internal/repository.PetRepository -o pet_repository_mock.go -n PetRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/escoutdoor/kotopes/pet/internal/model"
	"github.com/gojuno/minimock/v3"
)

// PetRepositoryMock implements mm_repository.PetRepository
type PetRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, in *model.CreatePet) (s1 string, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, in *model.CreatePet)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPetRepositoryMockCreate

	funcDelete          func(ctx context.Context, id string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mPetRepositoryMockDelete

	funcGetByID          func(ctx context.Context, id string) (pp1 *model.Pet, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, id string)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mPetRepositoryMockGetByID

	funcListPets          func(ctx context.Context, in *model.ListPets) (ppa1 []*model.Pet, err error)
	funcListPetsOrigin    string
	inspectFuncListPets   func(ctx context.Context, in *model.ListPets)
	afterListPetsCounter  uint64
	beforeListPetsCounter uint64
	ListPetsMock          mPetRepositoryMockListPets

	funcUpdate          func(ctx context.Context, in *model.UpdatePet) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, in *model.UpdatePet)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mPetRepositoryMockUpdate
}

// NewPetRepositoryMock returns a mock for mm_repository.PetRepository
func NewPetRepositoryMock(t minimock.Tester) *PetRepositoryMock {
	m := &PetRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPetRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*PetRepositoryMockCreateParams{}

	m.DeleteMock = mPetRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*PetRepositoryMockDeleteParams{}

	m.GetByIDMock = mPetRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*PetRepositoryMockGetByIDParams{}

	m.ListPetsMock = mPetRepositoryMockListPets{mock: m}
	m.ListPetsMock.callArgs = []*PetRepositoryMockListPetsParams{}

	m.UpdateMock = mPetRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*PetRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPetRepositoryMockCreate struct {
	optional           bool
	mock               *PetRepositoryMock
	defaultExpectation *PetRepositoryMockCreateExpectation
	expectations       []*PetRepositoryMockCreateExpectation

	callArgs []*PetRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PetRepositoryMockCreateExpectation specifies expectation struct of the PetRepository.Create
type PetRepositoryMockCreateExpectation struct {
	mock               *PetRepositoryMock
	params             *PetRepositoryMockCreateParams
	paramPtrs          *PetRepositoryMockCreateParamPtrs
	expectationOrigins PetRepositoryMockCreateExpectationOrigins
	results            *PetRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// PetRepositoryMockCreateParams contains parameters of the PetRepository.Create
type PetRepositoryMockCreateParams struct {
	ctx context.Context
	in  *model.CreatePet
}

// PetRepositoryMockCreateParamPtrs contains pointers to parameters of the PetRepository.Create
type PetRepositoryMockCreateParamPtrs struct {
	ctx *context.Context
	in  **model.CreatePet
}

// PetRepositoryMockCreateResults contains results of the PetRepository.Create
type PetRepositoryMockCreateResults struct {
	s1  string
	err error
}

// PetRepositoryMockCreateOrigins contains origins of expectations of the PetRepository.Create
type PetRepositoryMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mPetRepositoryMockCreate) Optional() *mPetRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for PetRepository.Create
func (mmCreate *mPetRepositoryMockCreate) Expect(ctx context.Context, in *model.CreatePet) *mPetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &PetRepositoryMockCreateParams{ctx, in}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for PetRepository.Create
func (mmCreate *mPetRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mPetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PetRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectInParam2 sets up expected param in for PetRepository.Create
func (mmCreate *mPetRepositoryMockCreate) ExpectInParam2(in *model.CreatePet) *mPetRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PetRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PetRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.in = &in
	mmCreate.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the PetRepository.Create
func (mmCreate *mPetRepositoryMockCreate) Inspect(f func(ctx context.Context, in *model.CreatePet)) *mPetRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PetRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by PetRepository.Create
func (mmCreate *mPetRepositoryMockCreate) Return(s1 string, err error) *PetRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PetRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &PetRepositoryMockCreateResults{s1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the PetRepository.Create method
func (mmCreate *mPetRepositoryMockCreate) Set(f func(ctx context.Context, in *model.CreatePet) (s1 string, err error)) *PetRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the PetRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the PetRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the PetRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPetRepositoryMockCreate) When(ctx context.Context, in *model.CreatePet) *PetRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PetRepositoryMock.Create mock is already set by Set")
	}

	expectation := &PetRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &PetRepositoryMockCreateParams{ctx, in},
		expectationOrigins: PetRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up PetRepository.Create return parameters for the expectation previously defined by the When method
func (e *PetRepositoryMockCreateExpectation) Then(s1 string, err error) *PetRepositoryMock {
	e.results = &PetRepositoryMockCreateResults{s1, err}
	return e.mock
}

// Times sets number of times PetRepository.Create should be invoked
func (mmCreate *mPetRepositoryMockCreate) Times(n uint64) *mPetRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of PetRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mPetRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.PetRepository
func (mmCreate *PetRepositoryMock) Create(ctx context.Context, in *model.CreatePet) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, in)
	}

	mm_params := PetRepositoryMockCreateParams{ctx, in}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := PetRepositoryMockCreateParams{ctx, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("PetRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreate.t.Errorf("PetRepositoryMock.Create got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PetRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the PetRepositoryMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, in)
	}
	mmCreate.t.Fatalf("Unexpected call to PetRepositoryMock.Create. %v %v", ctx, in)
	return
}

// CreateAfterCounter returns a count of finished PetRepositoryMock.Create invocations
func (mmCreate *PetRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PetRepositoryMock.Create invocations
func (mmCreate *PetRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PetRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPetRepositoryMockCreate) Calls() []*PetRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PetRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PetRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *PetRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PetRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PetRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to PetRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to PetRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mPetRepositoryMockDelete struct {
	optional           bool
	mock               *PetRepositoryMock
	defaultExpectation *PetRepositoryMockDeleteExpectation
	expectations       []*PetRepositoryMockDeleteExpectation

	callArgs []*PetRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PetRepositoryMockDeleteExpectation specifies expectation struct of the PetRepository.Delete
type PetRepositoryMockDeleteExpectation struct {
	mock               *PetRepositoryMock
	params             *PetRepositoryMockDeleteParams
	paramPtrs          *PetRepositoryMockDeleteParamPtrs
	expectationOrigins PetRepositoryMockDeleteExpectationOrigins
	results            *PetRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// PetRepositoryMockDeleteParams contains parameters of the PetRepository.Delete
type PetRepositoryMockDeleteParams struct {
	ctx context.Context
	id  string
}

// PetRepositoryMockDeleteParamPtrs contains pointers to parameters of the PetRepository.Delete
type PetRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *string
}

// PetRepositoryMockDeleteResults contains results of the PetRepository.Delete
type PetRepositoryMockDeleteResults struct {
	err error
}

// PetRepositoryMockDeleteOrigins contains origins of expectations of the PetRepository.Delete
type PetRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mPetRepositoryMockDelete) Optional() *mPetRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for PetRepository.Delete
func (mmDelete *mPetRepositoryMockDelete) Expect(ctx context.Context, id string) *mPetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &PetRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for PetRepository.Delete
func (mmDelete *mPetRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mPetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PetRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for PetRepository.Delete
func (mmDelete *mPetRepositoryMockDelete) ExpectIdParam2(id string) *mPetRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PetRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PetRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the PetRepository.Delete
func (mmDelete *mPetRepositoryMockDelete) Inspect(f func(ctx context.Context, id string)) *mPetRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for PetRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by PetRepository.Delete
func (mmDelete *mPetRepositoryMockDelete) Return(err error) *PetRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PetRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &PetRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the PetRepository.Delete method
func (mmDelete *mPetRepositoryMockDelete) Set(f func(ctx context.Context, id string) (err error)) *PetRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the PetRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the PetRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the PetRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mPetRepositoryMockDelete) When(ctx context.Context, id string) *PetRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PetRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &PetRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &PetRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: PetRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up PetRepository.Delete return parameters for the expectation previously defined by the When method
func (e *PetRepositoryMockDeleteExpectation) Then(err error) *PetRepositoryMock {
	e.results = &PetRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times PetRepository.Delete should be invoked
func (mmDelete *mPetRepositoryMockDelete) Times(n uint64) *mPetRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of PetRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mPetRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.PetRepository
func (mmDelete *PetRepositoryMock) Delete(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := PetRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := PetRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("PetRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("PetRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("PetRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the PetRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to PetRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished PetRepositoryMock.Delete invocations
func (mmDelete *PetRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of PetRepositoryMock.Delete invocations
func (mmDelete *PetRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to PetRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mPetRepositoryMockDelete) Calls() []*PetRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*PetRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *PetRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *PetRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PetRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PetRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to PetRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to PetRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mPetRepositoryMockGetByID struct {
	optional           bool
	mock               *PetRepositoryMock
	defaultExpectation *PetRepositoryMockGetByIDExpectation
	expectations       []*PetRepositoryMockGetByIDExpectation

	callArgs []*PetRepositoryMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PetRepositoryMockGetByIDExpectation specifies expectation struct of the PetRepository.GetByID
type PetRepositoryMockGetByIDExpectation struct {
	mock               *PetRepositoryMock
	params             *PetRepositoryMockGetByIDParams
	paramPtrs          *PetRepositoryMockGetByIDParamPtrs
	expectationOrigins PetRepositoryMockGetByIDExpectationOrigins
	results            *PetRepositoryMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// PetRepositoryMockGetByIDParams contains parameters of the PetRepository.GetByID
type PetRepositoryMockGetByIDParams struct {
	ctx context.Context
	id  string
}

// PetRepositoryMockGetByIDParamPtrs contains pointers to parameters of the PetRepository.GetByID
type PetRepositoryMockGetByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// PetRepositoryMockGetByIDResults contains results of the PetRepository.GetByID
type PetRepositoryMockGetByIDResults struct {
	pp1 *model.Pet
	err error
}

// PetRepositoryMockGetByIDOrigins contains origins of expectations of the PetRepository.GetByID
type PetRepositoryMockGetByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mPetRepositoryMockGetByID) Optional() *mPetRepositoryMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for PetRepository.GetByID
func (mmGetByID *mPetRepositoryMockGetByID) Expect(ctx context.Context, id string) *mPetRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PetRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &PetRepositoryMockGetByIDParams{ctx, id}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for PetRepository.GetByID
func (mmGetByID *mPetRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mPetRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PetRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &PetRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectIdParam2 sets up expected param id for PetRepository.GetByID
func (mmGetByID *mPetRepositoryMockGetByID) ExpectIdParam2(id string) *mPetRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PetRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &PetRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.id = &id
	mmGetByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the PetRepository.GetByID
func (mmGetByID *mPetRepositoryMockGetByID) Inspect(f func(ctx context.Context, id string)) *mPetRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for PetRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by PetRepository.GetByID
func (mmGetByID *mPetRepositoryMockGetByID) Return(pp1 *model.Pet, err error) *PetRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PetRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &PetRepositoryMockGetByIDResults{pp1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the PetRepository.GetByID method
func (mmGetByID *mPetRepositoryMockGetByID) Set(f func(ctx context.Context, id string) (pp1 *model.Pet, err error)) *PetRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the PetRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the PetRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the PetRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mPetRepositoryMockGetByID) When(ctx context.Context, id string) *PetRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PetRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &PetRepositoryMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &PetRepositoryMockGetByIDParams{ctx, id},
		expectationOrigins: PetRepositoryMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up PetRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *PetRepositoryMockGetByIDExpectation) Then(pp1 *model.Pet, err error) *PetRepositoryMock {
	e.results = &PetRepositoryMockGetByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times PetRepository.GetByID should be invoked
func (mmGetByID *mPetRepositoryMockGetByID) Times(n uint64) *mPetRepositoryMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of PetRepositoryMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mPetRepositoryMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_repository.PetRepository
func (mmGetByID *PetRepositoryMock) GetByID(ctx context.Context, id string) (pp1 *model.Pet, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := PetRepositoryMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := PetRepositoryMockGetByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("PetRepositoryMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetByID.t.Errorf("PetRepositoryMock.GetByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("PetRepositoryMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the PetRepositoryMock.GetByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to PetRepositoryMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished PetRepositoryMock.GetByID invocations
func (mmGetByID *PetRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of PetRepositoryMock.GetByID invocations
func (mmGetByID *PetRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to PetRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mPetRepositoryMockGetByID) Calls() []*PetRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*PetRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *PetRepositoryMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *PetRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetRepositoryMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PetRepositoryMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PetRepositoryMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to PetRepositoryMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PetRepositoryMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mPetRepositoryMockListPets struct {
	optional           bool
	mock               *PetRepositoryMock
	defaultExpectation *PetRepositoryMockListPetsExpectation
	expectations       []*PetRepositoryMockListPetsExpectation

	callArgs []*PetRepositoryMockListPetsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PetRepositoryMockListPetsExpectation specifies expectation struct of the PetRepository.ListPets
type PetRepositoryMockListPetsExpectation struct {
	mock               *PetRepositoryMock
	params             *PetRepositoryMockListPetsParams
	paramPtrs          *PetRepositoryMockListPetsParamPtrs
	expectationOrigins PetRepositoryMockListPetsExpectationOrigins
	results            *PetRepositoryMockListPetsResults
	returnOrigin       string
	Counter            uint64
}

// PetRepositoryMockListPetsParams contains parameters of the PetRepository.ListPets
type PetRepositoryMockListPetsParams struct {
	ctx context.Context
	in  *model.ListPets
}

// PetRepositoryMockListPetsParamPtrs contains pointers to parameters of the PetRepository.ListPets
type PetRepositoryMockListPetsParamPtrs struct {
	ctx *context.Context
	in  **model.ListPets
}

// PetRepositoryMockListPetsResults contains results of the PetRepository.ListPets
type PetRepositoryMockListPetsResults struct {
	ppa1 []*model.Pet
	err  error
}

// PetRepositoryMockListPetsOrigins contains origins of expectations of the PetRepository.ListPets
type PetRepositoryMockListPetsExpectationOrigins struct {
	origin    string
	originCtx string
	originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPets *mPetRepositoryMockListPets) Optional() *mPetRepositoryMockListPets {
	mmListPets.optional = true
	return mmListPets
}

// Expect sets up expected params for PetRepository.ListPets
func (mmListPets *mPetRepositoryMockListPets) Expect(ctx context.Context, in *model.ListPets) *mPetRepositoryMockListPets {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetRepositoryMockListPetsExpectation{}
	}

	if mmListPets.defaultExpectation.paramPtrs != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by ExpectParams functions")
	}

	mmListPets.defaultExpectation.params = &PetRepositoryMockListPetsParams{ctx, in}
	mmListPets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPets.expectations {
		if minimock.Equal(e.params, mmListPets.defaultExpectation.params) {
			mmListPets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPets.defaultExpectation.params)
		}
	}

	return mmListPets
}

// ExpectCtxParam1 sets up expected param ctx for PetRepository.ListPets
func (mmListPets *mPetRepositoryMockListPets) ExpectCtxParam1(ctx context.Context) *mPetRepositoryMockListPets {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetRepositoryMockListPetsExpectation{}
	}

	if mmListPets.defaultExpectation.params != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Expect")
	}

	if mmListPets.defaultExpectation.paramPtrs == nil {
		mmListPets.defaultExpectation.paramPtrs = &PetRepositoryMockListPetsParamPtrs{}
	}
	mmListPets.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPets
}

// ExpectInParam2 sets up expected param in for PetRepository.ListPets
func (mmListPets *mPetRepositoryMockListPets) ExpectInParam2(in *model.ListPets) *mPetRepositoryMockListPets {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetRepositoryMockListPetsExpectation{}
	}

	if mmListPets.defaultExpectation.params != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Expect")
	}

	if mmListPets.defaultExpectation.paramPtrs == nil {
		mmListPets.defaultExpectation.paramPtrs = &PetRepositoryMockListPetsParamPtrs{}
	}
	mmListPets.defaultExpectation.paramPtrs.in = &in
	mmListPets.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListPets
}

// Inspect accepts an inspector function that has same arguments as the PetRepository.ListPets
func (mmListPets *mPetRepositoryMockListPets) Inspect(f func(ctx context.Context, in *model.ListPets)) *mPetRepositoryMockListPets {
	if mmListPets.mock.inspectFuncListPets != nil {
		mmListPets.mock.t.Fatalf("Inspect function is already set for PetRepositoryMock.ListPets")
	}

	mmListPets.mock.inspectFuncListPets = f

	return mmListPets
}

// Return sets up results that will be returned by PetRepository.ListPets
func (mmListPets *mPetRepositoryMockListPets) Return(ppa1 []*model.Pet, err error) *PetRepositoryMock {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetRepositoryMockListPetsExpectation{mock: mmListPets.mock}
	}
	mmListPets.defaultExpectation.results = &PetRepositoryMockListPetsResults{ppa1, err}
	mmListPets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPets.mock
}

// Set uses given function f to mock the PetRepository.ListPets method
func (mmListPets *mPetRepositoryMockListPets) Set(f func(ctx context.Context, in *model.ListPets) (ppa1 []*model.Pet, err error)) *PetRepositoryMock {
	if mmListPets.defaultExpectation != nil {
		mmListPets.mock.t.Fatalf("Default expectation is already set for the PetRepository.ListPets method")
	}

	if len(mmListPets.expectations) > 0 {
		mmListPets.mock.t.Fatalf("Some expectations are already set for the PetRepository.ListPets method")
	}

	mmListPets.mock.funcListPets = f
	mmListPets.mock.funcListPetsOrigin = minimock.CallerInfo(1)
	return mmListPets.mock
}

// When sets expectation for the PetRepository.ListPets which will trigger the result defined by the following
// Then helper
func (mmListPets *mPetRepositoryMockListPets) When(ctx context.Context, in *model.ListPets) *PetRepositoryMockListPetsExpectation {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetRepositoryMock.ListPets mock is already set by Set")
	}

	expectation := &PetRepositoryMockListPetsExpectation{
		mock:               mmListPets.mock,
		params:             &PetRepositoryMockListPetsParams{ctx, in},
		expectationOrigins: PetRepositoryMockListPetsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPets.expectations = append(mmListPets.expectations, expectation)
	return expectation
}

// Then sets up PetRepository.ListPets return parameters for the expectation previously defined by the When method
func (e *PetRepositoryMockListPetsExpectation) Then(ppa1 []*model.Pet, err error) *PetRepositoryMock {
	e.results = &PetRepositoryMockListPetsResults{ppa1, err}
	return e.mock
}

// Times sets number of times PetRepository.ListPets should be invoked
func (mmListPets *mPetRepositoryMockListPets) Times(n uint64) *mPetRepositoryMockListPets {
	if n == 0 {
		mmListPets.mock.t.Fatalf("Times of PetRepositoryMock.ListPets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPets.expectedInvocations, n)
	mmListPets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPets
}

func (mmListPets *mPetRepositoryMockListPets) invocationsDone() bool {
	if len(mmListPets.expectations) == 0 && mmListPets.defaultExpectation == nil && mmListPets.mock.funcListPets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPets.mock.afterListPetsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPets implements mm_repository.PetRepository
func (mmListPets *PetRepositoryMock) ListPets(ctx context.Context, in *model.ListPets) (ppa1 []*model.Pet, err error) {
	mm_atomic.AddUint64(&mmListPets.beforeListPetsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPets.afterListPetsCounter, 1)

	mmListPets.t.Helper()

	if mmListPets.inspectFuncListPets != nil {
		mmListPets.inspectFuncListPets(ctx, in)
	}

	mm_params := PetRepositoryMockListPetsParams{ctx, in}

	// Record call args
	mmListPets.ListPetsMock.mutex.Lock()
	mmListPets.ListPetsMock.callArgs = append(mmListPets.ListPetsMock.callArgs, &mm_params)
	mmListPets.ListPetsMock.mutex.Unlock()

	for _, e := range mmListPets.ListPetsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmListPets.ListPetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPets.ListPetsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPets.ListPetsMock.defaultExpectation.params
		mm_want_ptrs := mmListPets.ListPetsMock.defaultExpectation.paramPtrs

		mm_got := PetRepositoryMockListPetsParams{ctx, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPets.t.Errorf("PetRepositoryMock.ListPets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPets.ListPetsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListPets.t.Errorf("PetRepositoryMock.ListPets got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPets.ListPetsMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPets.t.Errorf("PetRepositoryMock.ListPets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPets.ListPetsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPets.ListPetsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPets.t.Fatal("No results are set for the PetRepositoryMock.ListPets")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmListPets.funcListPets != nil {
		return mmListPets.funcListPets(ctx, in)
	}
	mmListPets.t.Fatalf("Unexpected call to PetRepositoryMock.ListPets. %v %v", ctx, in)
	return
}

// ListPetsAfterCounter returns a count of finished PetRepositoryMock.ListPets invocations
func (mmListPets *PetRepositoryMock) ListPetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPets.afterListPetsCounter)
}

// ListPetsBeforeCounter returns a count of PetRepositoryMock.ListPets invocations
func (mmListPets *PetRepositoryMock) ListPetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPets.beforeListPetsCounter)
}

// Calls returns a list of arguments used in each call to PetRepositoryMock.ListPets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPets *mPetRepositoryMockListPets) Calls() []*PetRepositoryMockListPetsParams {
	mmListPets.mutex.RLock()

	argCopy := make([]*PetRepositoryMockListPetsParams, len(mmListPets.callArgs))
	copy(argCopy, mmListPets.callArgs)

	mmListPets.mutex.RUnlock()

	return argCopy
}

// MinimockListPetsDone returns true if the count of the ListPets invocations corresponds
// the number of defined expectations
func (m *PetRepositoryMock) MinimockListPetsDone() bool {
	if m.ListPetsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPetsMock.invocationsDone()
}

// MinimockListPetsInspect logs each unmet expectation
func (m *PetRepositoryMock) MinimockListPetsInspect() {
	for _, e := range m.ListPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetRepositoryMock.ListPets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPetsCounter := mm_atomic.LoadUint64(&m.afterListPetsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPetsMock.defaultExpectation != nil && afterListPetsCounter < 1 {
		if m.ListPetsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PetRepositoryMock.ListPets at\n%s", m.ListPetsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PetRepositoryMock.ListPets at\n%s with params: %#v", m.ListPetsMock.defaultExpectation.expectationOrigins.origin, *m.ListPetsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPets != nil && afterListPetsCounter < 1 {
		m.t.Errorf("Expected call to PetRepositoryMock.ListPets at\n%s", m.funcListPetsOrigin)
	}

	if !m.ListPetsMock.invocationsDone() && afterListPetsCounter > 0 {
		m.t.Errorf("Expected %d calls to PetRepositoryMock.ListPets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPetsMock.expectedInvocations), m.ListPetsMock.expectedInvocationsOrigin, afterListPetsCounter)
	}
}

type mPetRepositoryMockUpdate struct {
	optional           bool
	mock               *PetRepositoryMock
	defaultExpectation *PetRepositoryMockUpdateExpectation
	expectations       []*PetRepositoryMockUpdateExpectation

	callArgs []*PetRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PetRepositoryMockUpdateExpectation specifies expectation struct of the PetRepository.Update
type PetRepositoryMockUpdateExpectation struct {
	mock               *PetRepositoryMock
	params             *PetRepositoryMockUpdateParams
	paramPtrs          *PetRepositoryMockUpdateParamPtrs
	expectationOrigins PetRepositoryMockUpdateExpectationOrigins
	results            *PetRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// PetRepositoryMockUpdateParams contains parameters of the PetRepository.Update
type PetRepositoryMockUpdateParams struct {
	ctx context.Context
	in  *model.UpdatePet
}

// PetRepositoryMockUpdateParamPtrs contains pointers to parameters of the PetRepository.Update
type PetRepositoryMockUpdateParamPtrs struct {
	ctx *context.Context
	in  **model.UpdatePet
}

// PetRepositoryMockUpdateResults contains results of the PetRepository.Update
type PetRepositoryMockUpdateResults struct {
	err error
}

// PetRepositoryMockUpdateOrigins contains origins of expectations of the PetRepository.Update
type PetRepositoryMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originIn  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mPetRepositoryMockUpdate) Optional() *mPetRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for PetRepository.Update
func (mmUpdate *mPetRepositoryMockUpdate) Expect(ctx context.Context, in *model.UpdatePet) *mPetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &PetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &PetRepositoryMockUpdateParams{ctx, in}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for PetRepository.Update
func (mmUpdate *mPetRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mPetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &PetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &PetRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectInParam2 sets up expected param in for PetRepository.Update
func (mmUpdate *mPetRepositoryMockUpdate) ExpectInParam2(in *model.UpdatePet) *mPetRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &PetRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &PetRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.in = &in
	mmUpdate.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the PetRepository.Update
func (mmUpdate *mPetRepositoryMockUpdate) Inspect(f func(ctx context.Context, in *model.UpdatePet)) *mPetRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for PetRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by PetRepository.Update
func (mmUpdate *mPetRepositoryMockUpdate) Return(err error) *PetRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &PetRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &PetRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the PetRepository.Update method
func (mmUpdate *mPetRepositoryMockUpdate) Set(f func(ctx context.Context, in *model.UpdatePet) (err error)) *PetRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the PetRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the PetRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the PetRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mPetRepositoryMockUpdate) When(ctx context.Context, in *model.UpdatePet) *PetRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("PetRepositoryMock.Update mock is already set by Set")
	}

	expectation := &PetRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &PetRepositoryMockUpdateParams{ctx, in},
		expectationOrigins: PetRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up PetRepository.Update return parameters for the expectation previously defined by the When method
func (e *PetRepositoryMockUpdateExpectation) Then(err error) *PetRepositoryMock {
	e.results = &PetRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times PetRepository.Update should be invoked
func (mmUpdate *mPetRepositoryMockUpdate) Times(n uint64) *mPetRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of PetRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mPetRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.PetRepository
func (mmUpdate *PetRepositoryMock) Update(ctx context.Context, in *model.UpdatePet) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, in)
	}

	mm_params := PetRepositoryMockUpdateParams{ctx, in}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := PetRepositoryMockUpdateParams{ctx, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("PetRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdate.t.Errorf("PetRepositoryMock.Update got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("PetRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the PetRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, in)
	}
	mmUpdate.t.Fatalf("Unexpected call to PetRepositoryMock.Update. %v %v", ctx, in)
	return
}

// UpdateAfterCounter returns a count of finished PetRepositoryMock.Update invocations
func (mmUpdate *PetRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of PetRepositoryMock.Update invocations
func (mmUpdate *PetRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to PetRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mPetRepositoryMockUpdate) Calls() []*PetRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*PetRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *PetRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *PetRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PetRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PetRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to PetRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PetRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PetRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetByIDInspect()

			m.MinimockListPetsInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PetRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PetRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockListPetsDone() &&
		m.MinimockUpdateDone()
}
