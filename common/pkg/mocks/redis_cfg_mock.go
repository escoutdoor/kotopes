// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/escoutdoor/kotopes/common/pkg/redis/config.RedisCfg -o redis_cfg_mock.go -n RedisCfgMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RedisCfgMock implements mm_config.RedisCfg
type RedisCfgMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddr          func() (s1 string)
	funcAddrOrigin    string
	inspectFuncAddr   func()
	afterAddrCounter  uint64
	beforeAddrCounter uint64
	AddrMock          mRedisCfgMockAddr

	funcConnTimeout          func() (d1 time.Duration)
	funcConnTimeoutOrigin    string
	inspectFuncConnTimeout   func()
	afterConnTimeoutCounter  uint64
	beforeConnTimeoutCounter uint64
	ConnTimeoutMock          mRedisCfgMockConnTimeout

	funcDB          func() (i1 int)
	funcDBOrigin    string
	inspectFuncDB   func()
	afterDBCounter  uint64
	beforeDBCounter uint64
	DBMock          mRedisCfgMockDB

	funcIdleTimeout          func() (d1 time.Duration)
	funcIdleTimeoutOrigin    string
	inspectFuncIdleTimeout   func()
	afterIdleTimeoutCounter  uint64
	beforeIdleTimeoutCounter uint64
	IdleTimeoutMock          mRedisCfgMockIdleTimeout

	funcMaxIdle          func() (i1 int)
	funcMaxIdleOrigin    string
	inspectFuncMaxIdle   func()
	afterMaxIdleCounter  uint64
	beforeMaxIdleCounter uint64
	MaxIdleMock          mRedisCfgMockMaxIdle

	funcPassword          func() (s1 string)
	funcPasswordOrigin    string
	inspectFuncPassword   func()
	afterPasswordCounter  uint64
	beforePasswordCounter uint64
	PasswordMock          mRedisCfgMockPassword

	funcTTL          func() (d1 time.Duration)
	funcTTLOrigin    string
	inspectFuncTTL   func()
	afterTTLCounter  uint64
	beforeTTLCounter uint64
	TTLMock          mRedisCfgMockTTL
}

// NewRedisCfgMock returns a mock for mm_config.RedisCfg
func NewRedisCfgMock(t minimock.Tester) *RedisCfgMock {
	m := &RedisCfgMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddrMock = mRedisCfgMockAddr{mock: m}

	m.ConnTimeoutMock = mRedisCfgMockConnTimeout{mock: m}

	m.DBMock = mRedisCfgMockDB{mock: m}

	m.IdleTimeoutMock = mRedisCfgMockIdleTimeout{mock: m}

	m.MaxIdleMock = mRedisCfgMockMaxIdle{mock: m}

	m.PasswordMock = mRedisCfgMockPassword{mock: m}

	m.TTLMock = mRedisCfgMockTTL{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRedisCfgMockAddr struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockAddrExpectation
	expectations       []*RedisCfgMockAddrExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockAddrExpectation specifies expectation struct of the RedisCfg.Addr
type RedisCfgMockAddrExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockAddrResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockAddrResults contains results of the RedisCfg.Addr
type RedisCfgMockAddrResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddr *mRedisCfgMockAddr) Optional() *mRedisCfgMockAddr {
	mmAddr.optional = true
	return mmAddr
}

// Expect sets up expected params for RedisCfg.Addr
func (mmAddr *mRedisCfgMockAddr) Expect() *mRedisCfgMockAddr {
	if mmAddr.mock.funcAddr != nil {
		mmAddr.mock.t.Fatalf("RedisCfgMock.Addr mock is already set by Set")
	}

	if mmAddr.defaultExpectation == nil {
		mmAddr.defaultExpectation = &RedisCfgMockAddrExpectation{}
	}

	return mmAddr
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.Addr
func (mmAddr *mRedisCfgMockAddr) Inspect(f func()) *mRedisCfgMockAddr {
	if mmAddr.mock.inspectFuncAddr != nil {
		mmAddr.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.Addr")
	}

	mmAddr.mock.inspectFuncAddr = f

	return mmAddr
}

// Return sets up results that will be returned by RedisCfg.Addr
func (mmAddr *mRedisCfgMockAddr) Return(s1 string) *RedisCfgMock {
	if mmAddr.mock.funcAddr != nil {
		mmAddr.mock.t.Fatalf("RedisCfgMock.Addr mock is already set by Set")
	}

	if mmAddr.defaultExpectation == nil {
		mmAddr.defaultExpectation = &RedisCfgMockAddrExpectation{mock: mmAddr.mock}
	}
	mmAddr.defaultExpectation.results = &RedisCfgMockAddrResults{s1}
	mmAddr.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddr.mock
}

// Set uses given function f to mock the RedisCfg.Addr method
func (mmAddr *mRedisCfgMockAddr) Set(f func() (s1 string)) *RedisCfgMock {
	if mmAddr.defaultExpectation != nil {
		mmAddr.mock.t.Fatalf("Default expectation is already set for the RedisCfg.Addr method")
	}

	if len(mmAddr.expectations) > 0 {
		mmAddr.mock.t.Fatalf("Some expectations are already set for the RedisCfg.Addr method")
	}

	mmAddr.mock.funcAddr = f
	mmAddr.mock.funcAddrOrigin = minimock.CallerInfo(1)
	return mmAddr.mock
}

// Times sets number of times RedisCfg.Addr should be invoked
func (mmAddr *mRedisCfgMockAddr) Times(n uint64) *mRedisCfgMockAddr {
	if n == 0 {
		mmAddr.mock.t.Fatalf("Times of RedisCfgMock.Addr mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddr.expectedInvocations, n)
	mmAddr.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddr
}

func (mmAddr *mRedisCfgMockAddr) invocationsDone() bool {
	if len(mmAddr.expectations) == 0 && mmAddr.defaultExpectation == nil && mmAddr.mock.funcAddr == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddr.mock.afterAddrCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddr.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Addr implements mm_config.RedisCfg
func (mmAddr *RedisCfgMock) Addr() (s1 string) {
	mm_atomic.AddUint64(&mmAddr.beforeAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmAddr.afterAddrCounter, 1)

	mmAddr.t.Helper()

	if mmAddr.inspectFuncAddr != nil {
		mmAddr.inspectFuncAddr()
	}

	if mmAddr.AddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddr.AddrMock.defaultExpectation.Counter, 1)

		mm_results := mmAddr.AddrMock.defaultExpectation.results
		if mm_results == nil {
			mmAddr.t.Fatal("No results are set for the RedisCfgMock.Addr")
		}
		return (*mm_results).s1
	}
	if mmAddr.funcAddr != nil {
		return mmAddr.funcAddr()
	}
	mmAddr.t.Fatalf("Unexpected call to RedisCfgMock.Addr.")
	return
}

// AddrAfterCounter returns a count of finished RedisCfgMock.Addr invocations
func (mmAddr *RedisCfgMock) AddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddr.afterAddrCounter)
}

// AddrBeforeCounter returns a count of RedisCfgMock.Addr invocations
func (mmAddr *RedisCfgMock) AddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddr.beforeAddrCounter)
}

// MinimockAddrDone returns true if the count of the Addr invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockAddrDone() bool {
	if m.AddrMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddrMock.invocationsDone()
}

// MinimockAddrInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockAddrInspect() {
	for _, e := range m.AddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.Addr")
		}
	}

	afterAddrCounter := mm_atomic.LoadUint64(&m.afterAddrCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddrMock.defaultExpectation != nil && afterAddrCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.Addr at\n%s", m.AddrMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddr != nil && afterAddrCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.Addr at\n%s", m.funcAddrOrigin)
	}

	if !m.AddrMock.invocationsDone() && afterAddrCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.Addr at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddrMock.expectedInvocations), m.AddrMock.expectedInvocationsOrigin, afterAddrCounter)
	}
}

type mRedisCfgMockConnTimeout struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockConnTimeoutExpectation
	expectations       []*RedisCfgMockConnTimeoutExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockConnTimeoutExpectation specifies expectation struct of the RedisCfg.ConnTimeout
type RedisCfgMockConnTimeoutExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockConnTimeoutResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockConnTimeoutResults contains results of the RedisCfg.ConnTimeout
type RedisCfgMockConnTimeoutResults struct {
	d1 time.Duration
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnTimeout *mRedisCfgMockConnTimeout) Optional() *mRedisCfgMockConnTimeout {
	mmConnTimeout.optional = true
	return mmConnTimeout
}

// Expect sets up expected params for RedisCfg.ConnTimeout
func (mmConnTimeout *mRedisCfgMockConnTimeout) Expect() *mRedisCfgMockConnTimeout {
	if mmConnTimeout.mock.funcConnTimeout != nil {
		mmConnTimeout.mock.t.Fatalf("RedisCfgMock.ConnTimeout mock is already set by Set")
	}

	if mmConnTimeout.defaultExpectation == nil {
		mmConnTimeout.defaultExpectation = &RedisCfgMockConnTimeoutExpectation{}
	}

	return mmConnTimeout
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.ConnTimeout
func (mmConnTimeout *mRedisCfgMockConnTimeout) Inspect(f func()) *mRedisCfgMockConnTimeout {
	if mmConnTimeout.mock.inspectFuncConnTimeout != nil {
		mmConnTimeout.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.ConnTimeout")
	}

	mmConnTimeout.mock.inspectFuncConnTimeout = f

	return mmConnTimeout
}

// Return sets up results that will be returned by RedisCfg.ConnTimeout
func (mmConnTimeout *mRedisCfgMockConnTimeout) Return(d1 time.Duration) *RedisCfgMock {
	if mmConnTimeout.mock.funcConnTimeout != nil {
		mmConnTimeout.mock.t.Fatalf("RedisCfgMock.ConnTimeout mock is already set by Set")
	}

	if mmConnTimeout.defaultExpectation == nil {
		mmConnTimeout.defaultExpectation = &RedisCfgMockConnTimeoutExpectation{mock: mmConnTimeout.mock}
	}
	mmConnTimeout.defaultExpectation.results = &RedisCfgMockConnTimeoutResults{d1}
	mmConnTimeout.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConnTimeout.mock
}

// Set uses given function f to mock the RedisCfg.ConnTimeout method
func (mmConnTimeout *mRedisCfgMockConnTimeout) Set(f func() (d1 time.Duration)) *RedisCfgMock {
	if mmConnTimeout.defaultExpectation != nil {
		mmConnTimeout.mock.t.Fatalf("Default expectation is already set for the RedisCfg.ConnTimeout method")
	}

	if len(mmConnTimeout.expectations) > 0 {
		mmConnTimeout.mock.t.Fatalf("Some expectations are already set for the RedisCfg.ConnTimeout method")
	}

	mmConnTimeout.mock.funcConnTimeout = f
	mmConnTimeout.mock.funcConnTimeoutOrigin = minimock.CallerInfo(1)
	return mmConnTimeout.mock
}

// Times sets number of times RedisCfg.ConnTimeout should be invoked
func (mmConnTimeout *mRedisCfgMockConnTimeout) Times(n uint64) *mRedisCfgMockConnTimeout {
	if n == 0 {
		mmConnTimeout.mock.t.Fatalf("Times of RedisCfgMock.ConnTimeout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConnTimeout.expectedInvocations, n)
	mmConnTimeout.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConnTimeout
}

func (mmConnTimeout *mRedisCfgMockConnTimeout) invocationsDone() bool {
	if len(mmConnTimeout.expectations) == 0 && mmConnTimeout.defaultExpectation == nil && mmConnTimeout.mock.funcConnTimeout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConnTimeout.mock.afterConnTimeoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConnTimeout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConnTimeout implements mm_config.RedisCfg
func (mmConnTimeout *RedisCfgMock) ConnTimeout() (d1 time.Duration) {
	mm_atomic.AddUint64(&mmConnTimeout.beforeConnTimeoutCounter, 1)
	defer mm_atomic.AddUint64(&mmConnTimeout.afterConnTimeoutCounter, 1)

	mmConnTimeout.t.Helper()

	if mmConnTimeout.inspectFuncConnTimeout != nil {
		mmConnTimeout.inspectFuncConnTimeout()
	}

	if mmConnTimeout.ConnTimeoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnTimeout.ConnTimeoutMock.defaultExpectation.Counter, 1)

		mm_results := mmConnTimeout.ConnTimeoutMock.defaultExpectation.results
		if mm_results == nil {
			mmConnTimeout.t.Fatal("No results are set for the RedisCfgMock.ConnTimeout")
		}
		return (*mm_results).d1
	}
	if mmConnTimeout.funcConnTimeout != nil {
		return mmConnTimeout.funcConnTimeout()
	}
	mmConnTimeout.t.Fatalf("Unexpected call to RedisCfgMock.ConnTimeout.")
	return
}

// ConnTimeoutAfterCounter returns a count of finished RedisCfgMock.ConnTimeout invocations
func (mmConnTimeout *RedisCfgMock) ConnTimeoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnTimeout.afterConnTimeoutCounter)
}

// ConnTimeoutBeforeCounter returns a count of RedisCfgMock.ConnTimeout invocations
func (mmConnTimeout *RedisCfgMock) ConnTimeoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnTimeout.beforeConnTimeoutCounter)
}

// MinimockConnTimeoutDone returns true if the count of the ConnTimeout invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockConnTimeoutDone() bool {
	if m.ConnTimeoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnTimeoutMock.invocationsDone()
}

// MinimockConnTimeoutInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockConnTimeoutInspect() {
	for _, e := range m.ConnTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.ConnTimeout")
		}
	}

	afterConnTimeoutCounter := mm_atomic.LoadUint64(&m.afterConnTimeoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnTimeoutMock.defaultExpectation != nil && afterConnTimeoutCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.ConnTimeout at\n%s", m.ConnTimeoutMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnTimeout != nil && afterConnTimeoutCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.ConnTimeout at\n%s", m.funcConnTimeoutOrigin)
	}

	if !m.ConnTimeoutMock.invocationsDone() && afterConnTimeoutCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.ConnTimeout at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnTimeoutMock.expectedInvocations), m.ConnTimeoutMock.expectedInvocationsOrigin, afterConnTimeoutCounter)
	}
}

type mRedisCfgMockDB struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockDBExpectation
	expectations       []*RedisCfgMockDBExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockDBExpectation specifies expectation struct of the RedisCfg.DB
type RedisCfgMockDBExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockDBResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockDBResults contains results of the RedisCfg.DB
type RedisCfgMockDBResults struct {
	i1 int
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDB *mRedisCfgMockDB) Optional() *mRedisCfgMockDB {
	mmDB.optional = true
	return mmDB
}

// Expect sets up expected params for RedisCfg.DB
func (mmDB *mRedisCfgMockDB) Expect() *mRedisCfgMockDB {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("RedisCfgMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &RedisCfgMockDBExpectation{}
	}

	return mmDB
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.DB
func (mmDB *mRedisCfgMockDB) Inspect(f func()) *mRedisCfgMockDB {
	if mmDB.mock.inspectFuncDB != nil {
		mmDB.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.DB")
	}

	mmDB.mock.inspectFuncDB = f

	return mmDB
}

// Return sets up results that will be returned by RedisCfg.DB
func (mmDB *mRedisCfgMockDB) Return(i1 int) *RedisCfgMock {
	if mmDB.mock.funcDB != nil {
		mmDB.mock.t.Fatalf("RedisCfgMock.DB mock is already set by Set")
	}

	if mmDB.defaultExpectation == nil {
		mmDB.defaultExpectation = &RedisCfgMockDBExpectation{mock: mmDB.mock}
	}
	mmDB.defaultExpectation.results = &RedisCfgMockDBResults{i1}
	mmDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Set uses given function f to mock the RedisCfg.DB method
func (mmDB *mRedisCfgMockDB) Set(f func() (i1 int)) *RedisCfgMock {
	if mmDB.defaultExpectation != nil {
		mmDB.mock.t.Fatalf("Default expectation is already set for the RedisCfg.DB method")
	}

	if len(mmDB.expectations) > 0 {
		mmDB.mock.t.Fatalf("Some expectations are already set for the RedisCfg.DB method")
	}

	mmDB.mock.funcDB = f
	mmDB.mock.funcDBOrigin = minimock.CallerInfo(1)
	return mmDB.mock
}

// Times sets number of times RedisCfg.DB should be invoked
func (mmDB *mRedisCfgMockDB) Times(n uint64) *mRedisCfgMockDB {
	if n == 0 {
		mmDB.mock.t.Fatalf("Times of RedisCfgMock.DB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDB.expectedInvocations, n)
	mmDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDB
}

func (mmDB *mRedisCfgMockDB) invocationsDone() bool {
	if len(mmDB.expectations) == 0 && mmDB.defaultExpectation == nil && mmDB.mock.funcDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDB.mock.afterDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DB implements mm_config.RedisCfg
func (mmDB *RedisCfgMock) DB() (i1 int) {
	mm_atomic.AddUint64(&mmDB.beforeDBCounter, 1)
	defer mm_atomic.AddUint64(&mmDB.afterDBCounter, 1)

	mmDB.t.Helper()

	if mmDB.inspectFuncDB != nil {
		mmDB.inspectFuncDB()
	}

	if mmDB.DBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDB.DBMock.defaultExpectation.Counter, 1)

		mm_results := mmDB.DBMock.defaultExpectation.results
		if mm_results == nil {
			mmDB.t.Fatal("No results are set for the RedisCfgMock.DB")
		}
		return (*mm_results).i1
	}
	if mmDB.funcDB != nil {
		return mmDB.funcDB()
	}
	mmDB.t.Fatalf("Unexpected call to RedisCfgMock.DB.")
	return
}

// DBAfterCounter returns a count of finished RedisCfgMock.DB invocations
func (mmDB *RedisCfgMock) DBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.afterDBCounter)
}

// DBBeforeCounter returns a count of RedisCfgMock.DB invocations
func (mmDB *RedisCfgMock) DBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDB.beforeDBCounter)
}

// MinimockDBDone returns true if the count of the DB invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockDBDone() bool {
	if m.DBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DBMock.invocationsDone()
}

// MinimockDBInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockDBInspect() {
	for _, e := range m.DBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.DB")
		}
	}

	afterDBCounter := mm_atomic.LoadUint64(&m.afterDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DBMock.defaultExpectation != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.DB at\n%s", m.DBMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDB != nil && afterDBCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.DB at\n%s", m.funcDBOrigin)
	}

	if !m.DBMock.invocationsDone() && afterDBCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.DB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DBMock.expectedInvocations), m.DBMock.expectedInvocationsOrigin, afterDBCounter)
	}
}

type mRedisCfgMockIdleTimeout struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockIdleTimeoutExpectation
	expectations       []*RedisCfgMockIdleTimeoutExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockIdleTimeoutExpectation specifies expectation struct of the RedisCfg.IdleTimeout
type RedisCfgMockIdleTimeoutExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockIdleTimeoutResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockIdleTimeoutResults contains results of the RedisCfg.IdleTimeout
type RedisCfgMockIdleTimeoutResults struct {
	d1 time.Duration
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Optional() *mRedisCfgMockIdleTimeout {
	mmIdleTimeout.optional = true
	return mmIdleTimeout
}

// Expect sets up expected params for RedisCfg.IdleTimeout
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Expect() *mRedisCfgMockIdleTimeout {
	if mmIdleTimeout.mock.funcIdleTimeout != nil {
		mmIdleTimeout.mock.t.Fatalf("RedisCfgMock.IdleTimeout mock is already set by Set")
	}

	if mmIdleTimeout.defaultExpectation == nil {
		mmIdleTimeout.defaultExpectation = &RedisCfgMockIdleTimeoutExpectation{}
	}

	return mmIdleTimeout
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.IdleTimeout
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Inspect(f func()) *mRedisCfgMockIdleTimeout {
	if mmIdleTimeout.mock.inspectFuncIdleTimeout != nil {
		mmIdleTimeout.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.IdleTimeout")
	}

	mmIdleTimeout.mock.inspectFuncIdleTimeout = f

	return mmIdleTimeout
}

// Return sets up results that will be returned by RedisCfg.IdleTimeout
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Return(d1 time.Duration) *RedisCfgMock {
	if mmIdleTimeout.mock.funcIdleTimeout != nil {
		mmIdleTimeout.mock.t.Fatalf("RedisCfgMock.IdleTimeout mock is already set by Set")
	}

	if mmIdleTimeout.defaultExpectation == nil {
		mmIdleTimeout.defaultExpectation = &RedisCfgMockIdleTimeoutExpectation{mock: mmIdleTimeout.mock}
	}
	mmIdleTimeout.defaultExpectation.results = &RedisCfgMockIdleTimeoutResults{d1}
	mmIdleTimeout.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIdleTimeout.mock
}

// Set uses given function f to mock the RedisCfg.IdleTimeout method
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Set(f func() (d1 time.Duration)) *RedisCfgMock {
	if mmIdleTimeout.defaultExpectation != nil {
		mmIdleTimeout.mock.t.Fatalf("Default expectation is already set for the RedisCfg.IdleTimeout method")
	}

	if len(mmIdleTimeout.expectations) > 0 {
		mmIdleTimeout.mock.t.Fatalf("Some expectations are already set for the RedisCfg.IdleTimeout method")
	}

	mmIdleTimeout.mock.funcIdleTimeout = f
	mmIdleTimeout.mock.funcIdleTimeoutOrigin = minimock.CallerInfo(1)
	return mmIdleTimeout.mock
}

// Times sets number of times RedisCfg.IdleTimeout should be invoked
func (mmIdleTimeout *mRedisCfgMockIdleTimeout) Times(n uint64) *mRedisCfgMockIdleTimeout {
	if n == 0 {
		mmIdleTimeout.mock.t.Fatalf("Times of RedisCfgMock.IdleTimeout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIdleTimeout.expectedInvocations, n)
	mmIdleTimeout.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIdleTimeout
}

func (mmIdleTimeout *mRedisCfgMockIdleTimeout) invocationsDone() bool {
	if len(mmIdleTimeout.expectations) == 0 && mmIdleTimeout.defaultExpectation == nil && mmIdleTimeout.mock.funcIdleTimeout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIdleTimeout.mock.afterIdleTimeoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIdleTimeout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IdleTimeout implements mm_config.RedisCfg
func (mmIdleTimeout *RedisCfgMock) IdleTimeout() (d1 time.Duration) {
	mm_atomic.AddUint64(&mmIdleTimeout.beforeIdleTimeoutCounter, 1)
	defer mm_atomic.AddUint64(&mmIdleTimeout.afterIdleTimeoutCounter, 1)

	mmIdleTimeout.t.Helper()

	if mmIdleTimeout.inspectFuncIdleTimeout != nil {
		mmIdleTimeout.inspectFuncIdleTimeout()
	}

	if mmIdleTimeout.IdleTimeoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIdleTimeout.IdleTimeoutMock.defaultExpectation.Counter, 1)

		mm_results := mmIdleTimeout.IdleTimeoutMock.defaultExpectation.results
		if mm_results == nil {
			mmIdleTimeout.t.Fatal("No results are set for the RedisCfgMock.IdleTimeout")
		}
		return (*mm_results).d1
	}
	if mmIdleTimeout.funcIdleTimeout != nil {
		return mmIdleTimeout.funcIdleTimeout()
	}
	mmIdleTimeout.t.Fatalf("Unexpected call to RedisCfgMock.IdleTimeout.")
	return
}

// IdleTimeoutAfterCounter returns a count of finished RedisCfgMock.IdleTimeout invocations
func (mmIdleTimeout *RedisCfgMock) IdleTimeoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIdleTimeout.afterIdleTimeoutCounter)
}

// IdleTimeoutBeforeCounter returns a count of RedisCfgMock.IdleTimeout invocations
func (mmIdleTimeout *RedisCfgMock) IdleTimeoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIdleTimeout.beforeIdleTimeoutCounter)
}

// MinimockIdleTimeoutDone returns true if the count of the IdleTimeout invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockIdleTimeoutDone() bool {
	if m.IdleTimeoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IdleTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IdleTimeoutMock.invocationsDone()
}

// MinimockIdleTimeoutInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockIdleTimeoutInspect() {
	for _, e := range m.IdleTimeoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.IdleTimeout")
		}
	}

	afterIdleTimeoutCounter := mm_atomic.LoadUint64(&m.afterIdleTimeoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IdleTimeoutMock.defaultExpectation != nil && afterIdleTimeoutCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.IdleTimeout at\n%s", m.IdleTimeoutMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIdleTimeout != nil && afterIdleTimeoutCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.IdleTimeout at\n%s", m.funcIdleTimeoutOrigin)
	}

	if !m.IdleTimeoutMock.invocationsDone() && afterIdleTimeoutCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.IdleTimeout at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IdleTimeoutMock.expectedInvocations), m.IdleTimeoutMock.expectedInvocationsOrigin, afterIdleTimeoutCounter)
	}
}

type mRedisCfgMockMaxIdle struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockMaxIdleExpectation
	expectations       []*RedisCfgMockMaxIdleExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockMaxIdleExpectation specifies expectation struct of the RedisCfg.MaxIdle
type RedisCfgMockMaxIdleExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockMaxIdleResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockMaxIdleResults contains results of the RedisCfg.MaxIdle
type RedisCfgMockMaxIdleResults struct {
	i1 int
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMaxIdle *mRedisCfgMockMaxIdle) Optional() *mRedisCfgMockMaxIdle {
	mmMaxIdle.optional = true
	return mmMaxIdle
}

// Expect sets up expected params for RedisCfg.MaxIdle
func (mmMaxIdle *mRedisCfgMockMaxIdle) Expect() *mRedisCfgMockMaxIdle {
	if mmMaxIdle.mock.funcMaxIdle != nil {
		mmMaxIdle.mock.t.Fatalf("RedisCfgMock.MaxIdle mock is already set by Set")
	}

	if mmMaxIdle.defaultExpectation == nil {
		mmMaxIdle.defaultExpectation = &RedisCfgMockMaxIdleExpectation{}
	}

	return mmMaxIdle
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.MaxIdle
func (mmMaxIdle *mRedisCfgMockMaxIdle) Inspect(f func()) *mRedisCfgMockMaxIdle {
	if mmMaxIdle.mock.inspectFuncMaxIdle != nil {
		mmMaxIdle.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.MaxIdle")
	}

	mmMaxIdle.mock.inspectFuncMaxIdle = f

	return mmMaxIdle
}

// Return sets up results that will be returned by RedisCfg.MaxIdle
func (mmMaxIdle *mRedisCfgMockMaxIdle) Return(i1 int) *RedisCfgMock {
	if mmMaxIdle.mock.funcMaxIdle != nil {
		mmMaxIdle.mock.t.Fatalf("RedisCfgMock.MaxIdle mock is already set by Set")
	}

	if mmMaxIdle.defaultExpectation == nil {
		mmMaxIdle.defaultExpectation = &RedisCfgMockMaxIdleExpectation{mock: mmMaxIdle.mock}
	}
	mmMaxIdle.defaultExpectation.results = &RedisCfgMockMaxIdleResults{i1}
	mmMaxIdle.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMaxIdle.mock
}

// Set uses given function f to mock the RedisCfg.MaxIdle method
func (mmMaxIdle *mRedisCfgMockMaxIdle) Set(f func() (i1 int)) *RedisCfgMock {
	if mmMaxIdle.defaultExpectation != nil {
		mmMaxIdle.mock.t.Fatalf("Default expectation is already set for the RedisCfg.MaxIdle method")
	}

	if len(mmMaxIdle.expectations) > 0 {
		mmMaxIdle.mock.t.Fatalf("Some expectations are already set for the RedisCfg.MaxIdle method")
	}

	mmMaxIdle.mock.funcMaxIdle = f
	mmMaxIdle.mock.funcMaxIdleOrigin = minimock.CallerInfo(1)
	return mmMaxIdle.mock
}

// Times sets number of times RedisCfg.MaxIdle should be invoked
func (mmMaxIdle *mRedisCfgMockMaxIdle) Times(n uint64) *mRedisCfgMockMaxIdle {
	if n == 0 {
		mmMaxIdle.mock.t.Fatalf("Times of RedisCfgMock.MaxIdle mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMaxIdle.expectedInvocations, n)
	mmMaxIdle.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMaxIdle
}

func (mmMaxIdle *mRedisCfgMockMaxIdle) invocationsDone() bool {
	if len(mmMaxIdle.expectations) == 0 && mmMaxIdle.defaultExpectation == nil && mmMaxIdle.mock.funcMaxIdle == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMaxIdle.mock.afterMaxIdleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMaxIdle.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MaxIdle implements mm_config.RedisCfg
func (mmMaxIdle *RedisCfgMock) MaxIdle() (i1 int) {
	mm_atomic.AddUint64(&mmMaxIdle.beforeMaxIdleCounter, 1)
	defer mm_atomic.AddUint64(&mmMaxIdle.afterMaxIdleCounter, 1)

	mmMaxIdle.t.Helper()

	if mmMaxIdle.inspectFuncMaxIdle != nil {
		mmMaxIdle.inspectFuncMaxIdle()
	}

	if mmMaxIdle.MaxIdleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMaxIdle.MaxIdleMock.defaultExpectation.Counter, 1)

		mm_results := mmMaxIdle.MaxIdleMock.defaultExpectation.results
		if mm_results == nil {
			mmMaxIdle.t.Fatal("No results are set for the RedisCfgMock.MaxIdle")
		}
		return (*mm_results).i1
	}
	if mmMaxIdle.funcMaxIdle != nil {
		return mmMaxIdle.funcMaxIdle()
	}
	mmMaxIdle.t.Fatalf("Unexpected call to RedisCfgMock.MaxIdle.")
	return
}

// MaxIdleAfterCounter returns a count of finished RedisCfgMock.MaxIdle invocations
func (mmMaxIdle *RedisCfgMock) MaxIdleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaxIdle.afterMaxIdleCounter)
}

// MaxIdleBeforeCounter returns a count of RedisCfgMock.MaxIdle invocations
func (mmMaxIdle *RedisCfgMock) MaxIdleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMaxIdle.beforeMaxIdleCounter)
}

// MinimockMaxIdleDone returns true if the count of the MaxIdle invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockMaxIdleDone() bool {
	if m.MaxIdleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MaxIdleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MaxIdleMock.invocationsDone()
}

// MinimockMaxIdleInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockMaxIdleInspect() {
	for _, e := range m.MaxIdleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.MaxIdle")
		}
	}

	afterMaxIdleCounter := mm_atomic.LoadUint64(&m.afterMaxIdleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MaxIdleMock.defaultExpectation != nil && afterMaxIdleCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.MaxIdle at\n%s", m.MaxIdleMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMaxIdle != nil && afterMaxIdleCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.MaxIdle at\n%s", m.funcMaxIdleOrigin)
	}

	if !m.MaxIdleMock.invocationsDone() && afterMaxIdleCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.MaxIdle at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MaxIdleMock.expectedInvocations), m.MaxIdleMock.expectedInvocationsOrigin, afterMaxIdleCounter)
	}
}

type mRedisCfgMockPassword struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockPasswordExpectation
	expectations       []*RedisCfgMockPasswordExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockPasswordExpectation specifies expectation struct of the RedisCfg.Password
type RedisCfgMockPasswordExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockPasswordResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockPasswordResults contains results of the RedisCfg.Password
type RedisCfgMockPasswordResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPassword *mRedisCfgMockPassword) Optional() *mRedisCfgMockPassword {
	mmPassword.optional = true
	return mmPassword
}

// Expect sets up expected params for RedisCfg.Password
func (mmPassword *mRedisCfgMockPassword) Expect() *mRedisCfgMockPassword {
	if mmPassword.mock.funcPassword != nil {
		mmPassword.mock.t.Fatalf("RedisCfgMock.Password mock is already set by Set")
	}

	if mmPassword.defaultExpectation == nil {
		mmPassword.defaultExpectation = &RedisCfgMockPasswordExpectation{}
	}

	return mmPassword
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.Password
func (mmPassword *mRedisCfgMockPassword) Inspect(f func()) *mRedisCfgMockPassword {
	if mmPassword.mock.inspectFuncPassword != nil {
		mmPassword.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.Password")
	}

	mmPassword.mock.inspectFuncPassword = f

	return mmPassword
}

// Return sets up results that will be returned by RedisCfg.Password
func (mmPassword *mRedisCfgMockPassword) Return(s1 string) *RedisCfgMock {
	if mmPassword.mock.funcPassword != nil {
		mmPassword.mock.t.Fatalf("RedisCfgMock.Password mock is already set by Set")
	}

	if mmPassword.defaultExpectation == nil {
		mmPassword.defaultExpectation = &RedisCfgMockPasswordExpectation{mock: mmPassword.mock}
	}
	mmPassword.defaultExpectation.results = &RedisCfgMockPasswordResults{s1}
	mmPassword.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPassword.mock
}

// Set uses given function f to mock the RedisCfg.Password method
func (mmPassword *mRedisCfgMockPassword) Set(f func() (s1 string)) *RedisCfgMock {
	if mmPassword.defaultExpectation != nil {
		mmPassword.mock.t.Fatalf("Default expectation is already set for the RedisCfg.Password method")
	}

	if len(mmPassword.expectations) > 0 {
		mmPassword.mock.t.Fatalf("Some expectations are already set for the RedisCfg.Password method")
	}

	mmPassword.mock.funcPassword = f
	mmPassword.mock.funcPasswordOrigin = minimock.CallerInfo(1)
	return mmPassword.mock
}

// Times sets number of times RedisCfg.Password should be invoked
func (mmPassword *mRedisCfgMockPassword) Times(n uint64) *mRedisCfgMockPassword {
	if n == 0 {
		mmPassword.mock.t.Fatalf("Times of RedisCfgMock.Password mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPassword.expectedInvocations, n)
	mmPassword.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPassword
}

func (mmPassword *mRedisCfgMockPassword) invocationsDone() bool {
	if len(mmPassword.expectations) == 0 && mmPassword.defaultExpectation == nil && mmPassword.mock.funcPassword == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPassword.mock.afterPasswordCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPassword.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Password implements mm_config.RedisCfg
func (mmPassword *RedisCfgMock) Password() (s1 string) {
	mm_atomic.AddUint64(&mmPassword.beforePasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmPassword.afterPasswordCounter, 1)

	mmPassword.t.Helper()

	if mmPassword.inspectFuncPassword != nil {
		mmPassword.inspectFuncPassword()
	}

	if mmPassword.PasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPassword.PasswordMock.defaultExpectation.Counter, 1)

		mm_results := mmPassword.PasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmPassword.t.Fatal("No results are set for the RedisCfgMock.Password")
		}
		return (*mm_results).s1
	}
	if mmPassword.funcPassword != nil {
		return mmPassword.funcPassword()
	}
	mmPassword.t.Fatalf("Unexpected call to RedisCfgMock.Password.")
	return
}

// PasswordAfterCounter returns a count of finished RedisCfgMock.Password invocations
func (mmPassword *RedisCfgMock) PasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPassword.afterPasswordCounter)
}

// PasswordBeforeCounter returns a count of RedisCfgMock.Password invocations
func (mmPassword *RedisCfgMock) PasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPassword.beforePasswordCounter)
}

// MinimockPasswordDone returns true if the count of the Password invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockPasswordDone() bool {
	if m.PasswordMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PasswordMock.invocationsDone()
}

// MinimockPasswordInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockPasswordInspect() {
	for _, e := range m.PasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.Password")
		}
	}

	afterPasswordCounter := mm_atomic.LoadUint64(&m.afterPasswordCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordMock.defaultExpectation != nil && afterPasswordCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.Password at\n%s", m.PasswordMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPassword != nil && afterPasswordCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.Password at\n%s", m.funcPasswordOrigin)
	}

	if !m.PasswordMock.invocationsDone() && afterPasswordCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.Password at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PasswordMock.expectedInvocations), m.PasswordMock.expectedInvocationsOrigin, afterPasswordCounter)
	}
}

type mRedisCfgMockTTL struct {
	optional           bool
	mock               *RedisCfgMock
	defaultExpectation *RedisCfgMockTTLExpectation
	expectations       []*RedisCfgMockTTLExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCfgMockTTLExpectation specifies expectation struct of the RedisCfg.TTL
type RedisCfgMockTTLExpectation struct {
	mock *RedisCfgMock

	results      *RedisCfgMockTTLResults
	returnOrigin string
	Counter      uint64
}

// RedisCfgMockTTLResults contains results of the RedisCfg.TTL
type RedisCfgMockTTLResults struct {
	d1 time.Duration
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTTL *mRedisCfgMockTTL) Optional() *mRedisCfgMockTTL {
	mmTTL.optional = true
	return mmTTL
}

// Expect sets up expected params for RedisCfg.TTL
func (mmTTL *mRedisCfgMockTTL) Expect() *mRedisCfgMockTTL {
	if mmTTL.mock.funcTTL != nil {
		mmTTL.mock.t.Fatalf("RedisCfgMock.TTL mock is already set by Set")
	}

	if mmTTL.defaultExpectation == nil {
		mmTTL.defaultExpectation = &RedisCfgMockTTLExpectation{}
	}

	return mmTTL
}

// Inspect accepts an inspector function that has same arguments as the RedisCfg.TTL
func (mmTTL *mRedisCfgMockTTL) Inspect(f func()) *mRedisCfgMockTTL {
	if mmTTL.mock.inspectFuncTTL != nil {
		mmTTL.mock.t.Fatalf("Inspect function is already set for RedisCfgMock.TTL")
	}

	mmTTL.mock.inspectFuncTTL = f

	return mmTTL
}

// Return sets up results that will be returned by RedisCfg.TTL
func (mmTTL *mRedisCfgMockTTL) Return(d1 time.Duration) *RedisCfgMock {
	if mmTTL.mock.funcTTL != nil {
		mmTTL.mock.t.Fatalf("RedisCfgMock.TTL mock is already set by Set")
	}

	if mmTTL.defaultExpectation == nil {
		mmTTL.defaultExpectation = &RedisCfgMockTTLExpectation{mock: mmTTL.mock}
	}
	mmTTL.defaultExpectation.results = &RedisCfgMockTTLResults{d1}
	mmTTL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTTL.mock
}

// Set uses given function f to mock the RedisCfg.TTL method
func (mmTTL *mRedisCfgMockTTL) Set(f func() (d1 time.Duration)) *RedisCfgMock {
	if mmTTL.defaultExpectation != nil {
		mmTTL.mock.t.Fatalf("Default expectation is already set for the RedisCfg.TTL method")
	}

	if len(mmTTL.expectations) > 0 {
		mmTTL.mock.t.Fatalf("Some expectations are already set for the RedisCfg.TTL method")
	}

	mmTTL.mock.funcTTL = f
	mmTTL.mock.funcTTLOrigin = minimock.CallerInfo(1)
	return mmTTL.mock
}

// Times sets number of times RedisCfg.TTL should be invoked
func (mmTTL *mRedisCfgMockTTL) Times(n uint64) *mRedisCfgMockTTL {
	if n == 0 {
		mmTTL.mock.t.Fatalf("Times of RedisCfgMock.TTL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTTL.expectedInvocations, n)
	mmTTL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTTL
}

func (mmTTL *mRedisCfgMockTTL) invocationsDone() bool {
	if len(mmTTL.expectations) == 0 && mmTTL.defaultExpectation == nil && mmTTL.mock.funcTTL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTTL.mock.afterTTLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTTL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TTL implements mm_config.RedisCfg
func (mmTTL *RedisCfgMock) TTL() (d1 time.Duration) {
	mm_atomic.AddUint64(&mmTTL.beforeTTLCounter, 1)
	defer mm_atomic.AddUint64(&mmTTL.afterTTLCounter, 1)

	mmTTL.t.Helper()

	if mmTTL.inspectFuncTTL != nil {
		mmTTL.inspectFuncTTL()
	}

	if mmTTL.TTLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTTL.TTLMock.defaultExpectation.Counter, 1)

		mm_results := mmTTL.TTLMock.defaultExpectation.results
		if mm_results == nil {
			mmTTL.t.Fatal("No results are set for the RedisCfgMock.TTL")
		}
		return (*mm_results).d1
	}
	if mmTTL.funcTTL != nil {
		return mmTTL.funcTTL()
	}
	mmTTL.t.Fatalf("Unexpected call to RedisCfgMock.TTL.")
	return
}

// TTLAfterCounter returns a count of finished RedisCfgMock.TTL invocations
func (mmTTL *RedisCfgMock) TTLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTTL.afterTTLCounter)
}

// TTLBeforeCounter returns a count of RedisCfgMock.TTL invocations
func (mmTTL *RedisCfgMock) TTLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTTL.beforeTTLCounter)
}

// MinimockTTLDone returns true if the count of the TTL invocations corresponds
// the number of defined expectations
func (m *RedisCfgMock) MinimockTTLDone() bool {
	if m.TTLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TTLMock.invocationsDone()
}

// MinimockTTLInspect logs each unmet expectation
func (m *RedisCfgMock) MinimockTTLInspect() {
	for _, e := range m.TTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisCfgMock.TTL")
		}
	}

	afterTTLCounter := mm_atomic.LoadUint64(&m.afterTTLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TTLMock.defaultExpectation != nil && afterTTLCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.TTL at\n%s", m.TTLMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTTL != nil && afterTTLCounter < 1 {
		m.t.Errorf("Expected call to RedisCfgMock.TTL at\n%s", m.funcTTLOrigin)
	}

	if !m.TTLMock.invocationsDone() && afterTTLCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCfgMock.TTL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TTLMock.expectedInvocations), m.TTLMock.expectedInvocationsOrigin, afterTTLCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RedisCfgMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddrInspect()

			m.MinimockConnTimeoutInspect()

			m.MinimockDBInspect()

			m.MinimockIdleTimeoutInspect()

			m.MinimockMaxIdleInspect()

			m.MinimockPasswordInspect()

			m.MinimockTTLInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RedisCfgMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RedisCfgMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddrDone() &&
		m.MinimockConnTimeoutDone() &&
		m.MinimockDBDone() &&
		m.MinimockIdleTimeoutDone() &&
		m.MinimockMaxIdleDone() &&
		m.MinimockPasswordDone() &&
		m.MinimockTTLDone()
}
