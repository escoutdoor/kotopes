// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/escoutdoor/kotopes/common/pkg/redis.Client -o redis_client_mock.go -n RedisClientMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RedisClientMock implements mm_redis.Client
type RedisClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRedisClientMockClose

	funcDelete          func(ctx context.Context, key string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, key string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mRedisClientMockDelete

	funcGet          func(ctx context.Context, key string, value interface{}) (err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key string, value interface{})
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRedisClientMockGet

	funcPing          func(ctx context.Context) (err error)
	funcPingOrigin    string
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mRedisClientMockPing

	funcSet          func(ctx context.Context, key string, value interface{}, expiration time.Duration) (err error)
	funcSetOrigin    string
	inspectFuncSet   func(ctx context.Context, key string, value interface{}, expiration time.Duration)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mRedisClientMockSet
}

// NewRedisClientMock returns a mock for mm_redis.Client
func NewRedisClientMock(t minimock.Tester) *RedisClientMock {
	m := &RedisClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRedisClientMockClose{mock: m}

	m.DeleteMock = mRedisClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*RedisClientMockDeleteParams{}

	m.GetMock = mRedisClientMockGet{mock: m}
	m.GetMock.callArgs = []*RedisClientMockGetParams{}

	m.PingMock = mRedisClientMockPing{mock: m}
	m.PingMock.callArgs = []*RedisClientMockPingParams{}

	m.SetMock = mRedisClientMockSet{mock: m}
	m.SetMock.callArgs = []*RedisClientMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRedisClientMockClose struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockCloseExpectation
	expectations       []*RedisClientMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockCloseExpectation specifies expectation struct of the Client.Close
type RedisClientMockCloseExpectation struct {
	mock *RedisClientMock

	results      *RedisClientMockCloseResults
	returnOrigin string
	Counter      uint64
}

// RedisClientMockCloseResults contains results of the Client.Close
type RedisClientMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mRedisClientMockClose) Optional() *mRedisClientMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Client.Close
func (mmClose *mRedisClientMockClose) Expect() *mRedisClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RedisClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RedisClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mRedisClientMockClose) Inspect(f func()) *mRedisClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mRedisClientMockClose) Return(err error) *RedisClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RedisClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RedisClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &RedisClientMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Client.Close method
func (mmClose *mRedisClientMockClose) Set(f func() (err error)) *RedisClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Client.Close should be invoked
func (mmClose *mRedisClientMockClose) Times(n uint64) *mRedisClientMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of RedisClientMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mRedisClientMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_redis.Client
func (mmClose *RedisClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the RedisClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to RedisClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished RedisClientMock.Close invocations
func (mmClose *RedisClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RedisClientMock.Close invocations
func (mmClose *RedisClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *RedisClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RedisClientMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mRedisClientMockDelete struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockDeleteExpectation
	expectations       []*RedisClientMockDeleteExpectation

	callArgs []*RedisClientMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockDeleteExpectation specifies expectation struct of the Client.Delete
type RedisClientMockDeleteExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockDeleteParams
	paramPtrs          *RedisClientMockDeleteParamPtrs
	expectationOrigins RedisClientMockDeleteExpectationOrigins
	results            *RedisClientMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockDeleteParams contains parameters of the Client.Delete
type RedisClientMockDeleteParams struct {
	ctx context.Context
	key string
}

// RedisClientMockDeleteParamPtrs contains pointers to parameters of the Client.Delete
type RedisClientMockDeleteParamPtrs struct {
	ctx *context.Context
	key *string
}

// RedisClientMockDeleteResults contains results of the Client.Delete
type RedisClientMockDeleteResults struct {
	err error
}

// RedisClientMockDeleteOrigins contains origins of expectations of the Client.Delete
type RedisClientMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mRedisClientMockDelete) Optional() *mRedisClientMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Client.Delete
func (mmDelete *mRedisClientMockDelete) Expect(ctx context.Context, key string) *mRedisClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RedisClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &RedisClientMockDeleteParams{ctx, key}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Client.Delete
func (mmDelete *mRedisClientMockDelete) ExpectCtxParam1(ctx context.Context) *mRedisClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RedisClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &RedisClientMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectKeyParam2 sets up expected param key for Client.Delete
func (mmDelete *mRedisClientMockDelete) ExpectKeyParam2(key string) *mRedisClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RedisClientMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &RedisClientMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.key = &key
	mmDelete.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Client.Delete
func (mmDelete *mRedisClientMockDelete) Inspect(f func(ctx context.Context, key string)) *mRedisClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Client.Delete
func (mmDelete *mRedisClientMockDelete) Return(err error) *RedisClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &RedisClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &RedisClientMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Client.Delete method
func (mmDelete *mRedisClientMockDelete) Set(f func(ctx context.Context, key string) (err error)) *RedisClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Client.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Client.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Client.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mRedisClientMockDelete) When(ctx context.Context, key string) *RedisClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("RedisClientMock.Delete mock is already set by Set")
	}

	expectation := &RedisClientMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &RedisClientMockDeleteParams{ctx, key},
		expectationOrigins: RedisClientMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Client.Delete return parameters for the expectation previously defined by the When method
func (e *RedisClientMockDeleteExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Client.Delete should be invoked
func (mmDelete *mRedisClientMockDelete) Times(n uint64) *mRedisClientMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of RedisClientMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mRedisClientMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_redis.Client
func (mmDelete *RedisClientMock) Delete(ctx context.Context, key string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, key)
	}

	mm_params := RedisClientMockDeleteParams{ctx, key}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockDeleteParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("RedisClientMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmDelete.t.Errorf("RedisClientMock.Delete got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("RedisClientMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the RedisClientMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, key)
	}
	mmDelete.t.Fatalf("Unexpected call to RedisClientMock.Delete. %v %v", ctx, key)
	return
}

// DeleteAfterCounter returns a count of finished RedisClientMock.Delete invocations
func (mmDelete *RedisClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of RedisClientMock.Delete invocations
func (mmDelete *RedisClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mRedisClientMockDelete) Calls() []*RedisClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*RedisClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *RedisClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mRedisClientMockGet struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockGetExpectation
	expectations       []*RedisClientMockGetExpectation

	callArgs []*RedisClientMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockGetExpectation specifies expectation struct of the Client.Get
type RedisClientMockGetExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockGetParams
	paramPtrs          *RedisClientMockGetParamPtrs
	expectationOrigins RedisClientMockGetExpectationOrigins
	results            *RedisClientMockGetResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockGetParams contains parameters of the Client.Get
type RedisClientMockGetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// RedisClientMockGetParamPtrs contains pointers to parameters of the Client.Get
type RedisClientMockGetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// RedisClientMockGetResults contains results of the Client.Get
type RedisClientMockGetResults struct {
	err error
}

// RedisClientMockGetOrigins contains origins of expectations of the Client.Get
type RedisClientMockGetExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mRedisClientMockGet) Optional() *mRedisClientMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Client.Get
func (mmGet *mRedisClientMockGet) Expect(ctx context.Context, key string, value interface{}) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &RedisClientMockGetParams{ctx, key, value}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Client.Get
func (mmGet *mRedisClientMockGet) ExpectCtxParam1(ctx context.Context) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for Client.Get
func (mmGet *mRedisClientMockGet) ExpectKeyParam2(key string) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// ExpectValueParam3 sets up expected param value for Client.Get
func (mmGet *mRedisClientMockGet) ExpectValueParam3(value interface{}) *mRedisClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisClientMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.value = &value
	mmGet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mRedisClientMockGet) Inspect(f func(ctx context.Context, key string, value interface{})) *mRedisClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mRedisClientMockGet) Return(err error) *RedisClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RedisClientMockGetResults{err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Client.Get method
func (mmGet *mRedisClientMockGet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *RedisClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRedisClientMockGet) When(ctx context.Context, key string, value interface{}) *RedisClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisClientMock.Get mock is already set by Set")
	}

	expectation := &RedisClientMockGetExpectation{
		mock:               mmGet.mock,
		params:             &RedisClientMockGetParams{ctx, key, value},
		expectationOrigins: RedisClientMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *RedisClientMockGetExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockGetResults{err}
	return e.mock
}

// Times sets number of times Client.Get should be invoked
func (mmGet *mRedisClientMockGet) Times(n uint64) *mRedisClientMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of RedisClientMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mRedisClientMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_redis.Client
func (mmGet *RedisClientMock) Get(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, value)
	}

	mm_params := RedisClientMockGetParams{ctx, key, value}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockGetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("RedisClientMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("RedisClientMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGet.t.Errorf("RedisClientMock.Get got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RedisClientMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RedisClientMock.Get")
		}
		return (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, value)
	}
	mmGet.t.Fatalf("Unexpected call to RedisClientMock.Get. %v %v %v", ctx, key, value)
	return
}

// GetAfterCounter returns a count of finished RedisClientMock.Get invocations
func (mmGet *RedisClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RedisClientMock.Get invocations
func (mmGet *RedisClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRedisClientMockGet) Calls() []*RedisClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RedisClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *RedisClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mRedisClientMockPing struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockPingExpectation
	expectations       []*RedisClientMockPingExpectation

	callArgs []*RedisClientMockPingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockPingExpectation specifies expectation struct of the Client.Ping
type RedisClientMockPingExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockPingParams
	paramPtrs          *RedisClientMockPingParamPtrs
	expectationOrigins RedisClientMockPingExpectationOrigins
	results            *RedisClientMockPingResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockPingParams contains parameters of the Client.Ping
type RedisClientMockPingParams struct {
	ctx context.Context
}

// RedisClientMockPingParamPtrs contains pointers to parameters of the Client.Ping
type RedisClientMockPingParamPtrs struct {
	ctx *context.Context
}

// RedisClientMockPingResults contains results of the Client.Ping
type RedisClientMockPingResults struct {
	err error
}

// RedisClientMockPingOrigins contains origins of expectations of the Client.Ping
type RedisClientMockPingExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mRedisClientMockPing) Optional() *mRedisClientMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for Client.Ping
func (mmPing *mRedisClientMockPing) Expect(ctx context.Context) *mRedisClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &RedisClientMockPingParams{ctx}
	mmPing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for Client.Ping
func (mmPing *mRedisClientMockPing) ExpectCtxParam1(ctx context.Context) *mRedisClientMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &RedisClientMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx
	mmPing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the Client.Ping
func (mmPing *mRedisClientMockPing) Inspect(f func(ctx context.Context)) *mRedisClientMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by Client.Ping
func (mmPing *mRedisClientMockPing) Return(err error) *RedisClientMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisClientMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &RedisClientMockPingResults{err}
	mmPing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// Set uses given function f to mock the Client.Ping method
func (mmPing *mRedisClientMockPing) Set(f func(ctx context.Context) (err error)) *RedisClientMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the Client.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the Client.Ping method")
	}

	mmPing.mock.funcPing = f
	mmPing.mock.funcPingOrigin = minimock.CallerInfo(1)
	return mmPing.mock
}

// When sets expectation for the Client.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mRedisClientMockPing) When(ctx context.Context) *RedisClientMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisClientMock.Ping mock is already set by Set")
	}

	expectation := &RedisClientMockPingExpectation{
		mock:               mmPing.mock,
		params:             &RedisClientMockPingParams{ctx},
		expectationOrigins: RedisClientMockPingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up Client.Ping return parameters for the expectation previously defined by the When method
func (e *RedisClientMockPingExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockPingResults{err}
	return e.mock
}

// Times sets number of times Client.Ping should be invoked
func (mmPing *mRedisClientMockPing) Times(n uint64) *mRedisClientMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of RedisClientMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	mmPing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPing
}

func (mmPing *mRedisClientMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements mm_redis.Client
func (mmPing *RedisClientMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	mmPing.t.Helper()

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := RedisClientMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("RedisClientMock.Ping got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPing.PingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("RedisClientMock.Ping got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPing.PingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the RedisClientMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to RedisClientMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished RedisClientMock.Ping invocations
func (mmPing *RedisClientMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of RedisClientMock.Ping invocations
func (mmPing *RedisClientMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mRedisClientMockPing) Calls() []*RedisClientMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*RedisClientMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *RedisClientMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s", m.PingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s with params: %#v", m.PingMock.defaultExpectation.expectationOrigins.origin, *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Ping at\n%s", m.funcPingOrigin)
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Ping at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), m.PingMock.expectedInvocationsOrigin, afterPingCounter)
	}
}

type mRedisClientMockSet struct {
	optional           bool
	mock               *RedisClientMock
	defaultExpectation *RedisClientMockSetExpectation
	expectations       []*RedisClientMockSetExpectation

	callArgs []*RedisClientMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisClientMockSetExpectation specifies expectation struct of the Client.Set
type RedisClientMockSetExpectation struct {
	mock               *RedisClientMock
	params             *RedisClientMockSetParams
	paramPtrs          *RedisClientMockSetParamPtrs
	expectationOrigins RedisClientMockSetExpectationOrigins
	results            *RedisClientMockSetResults
	returnOrigin       string
	Counter            uint64
}

// RedisClientMockSetParams contains parameters of the Client.Set
type RedisClientMockSetParams struct {
	ctx        context.Context
	key        string
	value      interface{}
	expiration time.Duration
}

// RedisClientMockSetParamPtrs contains pointers to parameters of the Client.Set
type RedisClientMockSetParamPtrs struct {
	ctx        *context.Context
	key        *string
	value      *interface{}
	expiration *time.Duration
}

// RedisClientMockSetResults contains results of the Client.Set
type RedisClientMockSetResults struct {
	err error
}

// RedisClientMockSetOrigins contains origins of expectations of the Client.Set
type RedisClientMockSetExpectationOrigins struct {
	origin           string
	originCtx        string
	originKey        string
	originValue      string
	originExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mRedisClientMockSet) Optional() *mRedisClientMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for Client.Set
func (mmSet *mRedisClientMockSet) Expect(ctx context.Context, key string, value interface{}, expiration time.Duration) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &RedisClientMockSetParams{ctx, key, value, expiration}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for Client.Set
func (mmSet *mRedisClientMockSet) ExpectCtxParam1(ctx context.Context) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for Client.Set
func (mmSet *mRedisClientMockSet) ExpectKeyParam2(key string) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key
	mmSet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSet
}

// ExpectValueParam3 sets up expected param value for Client.Set
func (mmSet *mRedisClientMockSet) ExpectValueParam3(value interface{}) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value
	mmSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSet
}

// ExpectExpirationParam4 sets up expected param expiration for Client.Set
func (mmSet *mRedisClientMockSet) ExpectExpirationParam4(expiration time.Duration) *mRedisClientMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisClientMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.expiration = &expiration
	mmSet.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Client.Set
func (mmSet *mRedisClientMockSet) Inspect(f func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *mRedisClientMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for RedisClientMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Client.Set
func (mmSet *mRedisClientMockSet) Return(err error) *RedisClientMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisClientMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &RedisClientMockSetResults{err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the Client.Set method
func (mmSet *mRedisClientMockSet) Set(f func(ctx context.Context, key string, value interface{}, expiration time.Duration) (err error)) *RedisClientMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Client.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Client.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the Client.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mRedisClientMockSet) When(ctx context.Context, key string, value interface{}, expiration time.Duration) *RedisClientMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisClientMock.Set mock is already set by Set")
	}

	expectation := &RedisClientMockSetExpectation{
		mock:               mmSet.mock,
		params:             &RedisClientMockSetParams{ctx, key, value, expiration},
		expectationOrigins: RedisClientMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Client.Set return parameters for the expectation previously defined by the When method
func (e *RedisClientMockSetExpectation) Then(err error) *RedisClientMock {
	e.results = &RedisClientMockSetResults{err}
	return e.mock
}

// Times sets number of times Client.Set should be invoked
func (mmSet *mRedisClientMockSet) Times(n uint64) *mRedisClientMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of RedisClientMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mRedisClientMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_redis.Client
func (mmSet *RedisClientMock) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value, expiration)
	}

	mm_params := RedisClientMockSetParams{ctx, key, value, expiration}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := RedisClientMockSetParams{ctx, key, value, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmSet.t.Errorf("RedisClientMock.Set got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("RedisClientMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the RedisClientMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value, expiration)
	}
	mmSet.t.Fatalf("Unexpected call to RedisClientMock.Set. %v %v %v %v", ctx, key, value, expiration)
	return
}

// SetAfterCounter returns a count of finished RedisClientMock.Set invocations
func (mmSet *RedisClientMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of RedisClientMock.Set invocations
func (mmSet *RedisClientMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to RedisClientMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mRedisClientMockSet) Calls() []*RedisClientMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*RedisClientMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *RedisClientMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *RedisClientMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisClientMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to RedisClientMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisClientMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RedisClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RedisClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RedisClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
